---
title: åŠ¨æ€è§„åˆ’
date: 2021-01-14
categories:
   - Practice
tags:
   - Leetcode
---


<big>èƒŒåŒ…é—®é¢˜</big>
::: right
ğŸ“¦ æ€ä¹ˆå°½å¯èƒ½åœ¨æœ‰é™ç©ºé—´çš„èƒŒåŒ…é‡Œå°½å¯èƒ½å¤šåœ°è£…è´§
- 473
- 474
- 279
:::

::::: tabs type: card
:::: tab é›¶é’±å…‘æ¢
## 322. Coin Change
__é—®é¢˜__: ç”¨æœ€å°‘çš„ç¡¬å¸å‡‘é½é¢†é’±(amount)

__ä¾‹å­__: æ¯”å¦‚ "coins = [1, 2, 5], amount = 11" æœ€å°‘ä¸‰æšç¡¬å¸å°±å¯ä»¥æå®š, å¦‚æœæä¸å®šè¿”å›`-1`

```coins = [2,5,1]
dp[i]    0   1   2   3   4   5   6   7   8   9  10  11
add 2    0  12   1  12   2  12   3  12   4  12   5  12
add 5    0  12   1  12   2   1   3   2   4   3   2  12
add 1    0   1   1   2   2   3   2   2   3   3   2   3
```
::: details 
åŠ¨æ€è§„åˆ’, æ¸…æ™°æ˜äº†, è§ä¸‹å›¾
```python
def coinChange(self, coins: List[int], amount: int) -> int:
    dp = [amount+1] * (amount + 1); dp[0] = 0
    for coin in coins:
        for i in range(coin, amount+1):
            dp[i] = min(dp[i], dp[i-coin]+1)
    return -1 if dp[-1] == amount+1 else dp[-1] 
```
:::
::::
:::: tab é›¶é’±å…‘æ¢äºŒ
## 518. Coin Change 2
__é—®é¢˜__ï¼š å’Œä¸Šé¢é‚£é“é¢˜å·®ä¸å¤š, åªæ˜¯é—®ä½ è¦å‡‘å¤Ÿ`amount`, ç”¨æ‰‹é‡Œè¿™å †ç¡¬å¸, æ€»å…±æœ‰å¤šå°‘ç§ä¸åŒç»„åˆæ–¹å¼

__ä¾‹å­__ï¼š æ¯”å¦‚ä¹‹å‰é‚£ä¸ªä¾‹å­æ€»å…±æœ‰11ç§æ–¹å¼

```coins = [2,5,1]
dp[i]    0   1   2   3   4   5   6   7   8   9  10  11
add 2    1   0   1   0   1   0   1   0   1   0   1   0
add 5    1   0   1   0   1   1   1   1   1   1   2   0
add 1    1   1   2   2   3   4   6   7   8   9  11  11
```
::: details
ä¸‹é¢ä¸¤ä¸ªç›¸åŠ å³å¯
- è¿˜æ²¡æ›´æ–°çš„`dp[i]`ä»£è¡¨ä¸addå½“å‰è¿™ä¸ªcoinæ—¶çš„ç­”æ¡ˆ
- `dp[i-coin]`ä»£è¡¨ç­”æ¡ˆä¸­å¿…é¡»åŒ…å«å½“å‰è¿™ä¸ªcoinçš„ç­”æ¡ˆä¸ªæ•°
```python
def change(self, amount: int, coins: List[int]) -> int:
    dp = [0] * (amount + 1); dp[0] = 1
    for coin in coins:
        for i in range(coin, amount+1):
            dp[i] += dp[i-coin]
    return dp[-1]
```
:::
::::
:::: tab åˆ†å‰²ä¸¤åŠ
## 416. Partition Equal Subset Sum

__é—®é¢˜__ï¼š åˆ¤æ–­æ˜¯å¦å¯ä»¥æŠŠä¸€ç»„æ•°å­—åˆ†æˆä¸¤å †ï¼Œä¸¤å †æ•°å­—çš„å’Œç›¸ç­‰

__ä¾‹å­__ï¼š "[1, 2, 3, 8]", ä¸å¯ä»¥åˆ†æˆç›¸ç­‰çš„ä¸¤å †

```nums=[3, 1, 2, 8]
dp[i]    0   1   2   3   4   5   6   7
add 3    T   F   F   T   F   F   F   F 
add 1    T   T   F   T   T   F   F   F 
add 2    T   T   T   T   T   T   T   F 
```

::: details
æ€»å’Œé™¤ä»¥2æ˜¯èƒŒåŒ…çš„è´Ÿè½½, æˆ‘ä»¬åªéœ€è¦ä¸€ä¸ªä¸€ä¸ªå¾€é‡Œæ›´æ–°, è¦ä»åå¾€å‰æ›´æ–°, å› ä¸ºæ•°å­—ä¸èƒ½é‡å¤è¢«ä½¿ç”¨, å°±
- `dp[i]`ä»£è¡¨ä¸åŠ å½“å‰`num`æƒ…å†µä¸‹, `total=i`æ˜¯å¦å‡‘å¾—é½
- `dp[i-num]`ä»£è¡¨è¿™ä¸€å †é‡Œä¸€å®šåŒ…å«å½“å‰`num`çš„æƒ…å†µä¸‹, `total=i`æ˜¯å¦å‡‘å¾—é½
```python
def canPartition(self, nums: List[int]) -> bool:
    target = sum(nums)
    if target % 2 == 1: return False
    target = target >> 1
    dp = [False] * (target + 1); dp[0] = True
    for num in nums:
        for i in range(target, num-1, -1):
            dp[i] |= dp[i-num]
    return dp[-1]
```
:::
::::
:::: tab ç›®æ ‡å’Œ
## 494. Target Sum
__é—®é¢˜__ï¼š ç»™å®šä¸€ä¸ªæ•°ç»„, æ¯ä¸€ä¸ªæ•°å­—å‰é¢å¯ä»¥åŠ ï¼‹æˆ–è€…ï¼, ç„¶ååŠ èµ·æ¥è¦ç­‰äºä¸€ä¸ªç»™å®šçš„æ•°å­—, è¯·é—®æœ‰å¤šå°‘ç§ä¸åŒçš„assignment(è¿™äº›ç¬¦å·)

__ä¾‹å­__ï¼š `nums=[1, 1, 1, 1, 1], S=3`, ä¸€å…±æœ‰5ç§, å…¶å®å°±æ˜¯"(sum(nums)-S) / 2"ä½œä¸ºèƒŒåŒ…çš„è´Ÿè½½, ç„¶åçœ‹æœ‰å¤šå°‘ä¸ªåŠ å’Œå¯èƒ½

::: details
ä¹Ÿæ˜¯ä¿æŒä»åå¾€å‰æ›´æ–°, å› ä¸ºä¸€ä¸ªæ•°å­—åªèƒ½ä½¿ç”¨ä¸€æ¬¡
```python
def findTargetSumWays(self, nums: List[int], S: int) -> int:
    target = sum(nums) - S
    if target % 2 == 1 or target < 0: return 0
    target = target >> 1
    dp = [0] * (target + 1); dp[0] = 1
    for num in nums:
        for i in range(target, num-1, -1):
            dp[i] += dp[i-num]
    return dp[-1] or 0
```
:::
::::
:::: tab æš‚æ— 

::::
:::::

--- 

## 413. Arithmetic Slices
__é—®é¢˜__ï¼š æ‰¾å‡ºä¸€ä¸ªæ•°ç»„æœ‰å¤šå°‘ä¸ªç­‰å·®æ•°åˆ—(è‡³å°‘ä¸‰ä¸ªæ•°)

__ä¾‹å­__ï¼š $A = [1, 2, 3, 4]$, æœ‰`[1,2,3]; [2,3,4]; [1,2,3,4]`å››ä¸ªç­‰å·®æ•°åˆ—ï¼Œæ•°åˆ—å¿…é¡»æ˜¯è¿ç»­æ•°å­—ï¼Œå¦‚æœå…è®¸éè¿ç»­ä¼šéš¾å¾ˆå¤š

::: details
é¦–å…ˆå¦‚æœæš´åŠ›ç ´è§£çš„è¯
- æ‰¾ä¸€ä¸ªå¼€å¤´`s`, æ‰¾ä¸€ä¸ªç»“å°¾`e=s+2`, çœ‹$A[s+1]-A[s]==A[s+2]-A[s+1]$å¦‚æœå¯ä»¥æ„æˆç­‰å·®æ•°åˆ—, å°±ç»§ç»­å¾€å³æŒªåŠ¨$e$, ä»£è¡¨å¯ä»¥ä»¥$s$ä¸ºèµ·ç‚¹åˆ›å»ºé•¿åº¦æ›´é•¿çš„ç­‰å·®æ•°åˆ—
- ä¸€æ—¦ä¸è¡Œ, å°±åœæ­¢æŒªåŠ¨$e$, è½¬è€Œç”¨æ–°çš„èµ·å§‹ç‚¹$s$å»æ‰¾æ–°çš„`difference`

ç”¨åŠ¨æ€è§„åˆ’, ç”Ÿæˆä¸‹é¢è¿™æ ·çš„ä¸œè¥¿, å…¶å®å°±æ˜¯å½¢æˆç­‰å·®æ•°åˆ—åç§»åŠ¨å³è¾¹çš„ç‚¹, ç„¶åå·¦è¾¹ä»å³è¾¹æ–­å¼€çš„ç‚¹å¼€å§‹é‡æ–°èµ°(è€Œä¸æ˜¯ä»ä¸Šä¸€ä¸ªèµ·å§‹ç‚¹+1å¼€å§‹çœ‹)

```python     
"""æ³¨æ„åŠ¨æ€è§„åˆ’å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ç©ºé—´, å› ä¸ºdp[i]åªå’Œdp[i-1]æœ‰å…³ç³»
A   1  3  5  7  9 15 20 25 28 29
dp  0  0  1  2  3  0  0  1  0  0
"""                       
def numberOfArithmeticSlices(self, A: List[int]) -> int:
    n = len(A); dp = [0] * n; res = 0
    for i in range(2,n):
        if A[i-1]*2 == A[i]+A[i-2]:
            dp[i] = dp[i-1] + 1
        else:
            dp[i] = 0
    return sum(dp)
```
:::

![413. Arithmetic Slices](~@assets/lc-413.png#center)

## 1105. Filling Bookcase Shelves

__é—®é¢˜__ï¼š è¦æ±‚æŠŠä¹¦(ä¸åŒåšåº¦å’Œé«˜åº¦)æŒ‰ç…§é¡ºåºæ”¾åœ¨ä¸€ä¸ªä¹¦æŸœé‡Œ(åˆ†å±‚), è¿™ä¸ªä¹¦æ¶æ˜¯æœ‰å›ºå®šå®½åº¦çš„, ä½†æ˜¯å¯ä»¥ä¸æ–­åŠ å±‚ã€‚

__ä¾‹å­__ï¼š books(å®½åº¦,é«˜åº¦) = $[[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]]$, shelf_width = $4$, è§ä¸‹å›¾

::: details
ç”¨åŠ¨æ€è§„åˆ’ä½œ, è®¾$d[i]$ä¸ºæ”¾ç½®å‰$i$æœ¬ä¹¦çš„æœ€å°é«˜åº¦, æŠŠå½“å‰è¿™æœ¬ä¹¦å°½é‡æ”¾åœ¨åŒä¸€å±‚, å¦‚æœè¶…äº†ä¹¦æŸœçš„å®½åº¦, åˆ™åŠ ä¸€å±‚, ==ä½†æ˜¯è¦æ³¨æ„ä¸Šä¸€å±‚çš„ä¹¦ä¹Ÿè®¸åº”è¯¥æ”¾ä¸‹æ¥æœ€å¥½, å› ä¸ºè¿™ä¸€å±‚ç›®å‰åªæœ‰ä¸€æœ¬ä¹¦==

```python
"""
dp[i] çš„èŒƒå›´æ³¨æ„ä¸€ä¸‹, æœ€å¤š1000æœ¬ä¹¦, æœ€é«˜1000, æ‰€ä»¥dp[i]çš„æœ€å¤§å€¼
è¿™é“é¢˜ç”¨äºŒåˆ†æ³•ä¹Ÿä¸å¥½åš, åŸå› å°±æ˜¯å›¾ä¸­çš„é‚£ä¸ª, å³ä½¿æœ‰é«˜åº¦é™åˆ¶, æ€ä¹ˆæ”¾è¿˜æ˜¯æœ‰trick
"""
def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:
    n = len(books); dp = [1000000] * (n+1); dp[0] = 0
    for i, book in enumerate(books):
        add_w = 0; max_h = 0
        for j in range(i, -1, -1):
            add_w += books[j][0]
            if add_w > shelf_width:
                break
            max_h = max(max_h, books[j][1])                
            dp[i+1] = min(dp[i+1], dp[j] + max_h)
    return dp[-1]
```
:::

![](~@assets/lc-1105.png#center)


## 1246. Palindrome Removal 

__é—®é¢˜__ï¼š æ¯æ¬¡å¯ä»¥åˆ é™¤ä¸€ä¸ªå›æ–‡å­æ•°ç»„(ä¸æ˜¯å­å­—ç¬¦ä¸², å°±æ˜¯è¯´å¿…é¡»æ˜¯é‚»è¿‘çš„æ‰å¯ä»¥), é—®å¤šå°‘æ¬¡å¯ä»¥åˆ é™¤å¹²å‡€

__ä¾‹å­__ï¼š "arr = [1,3,4,1,5]", å…ˆå…ˆåˆ é™¤ "[4]", ç„¶ååˆ é™¤ "[1,3,1]", æœ€åå†åˆ é™¤ "[5]"

::: details
ä¸»è¦æ˜¯è€ƒè™‘"arr[i, j]"éœ€è¦å¤šå°‘æ­¥, å¦‚æœ$i=j$, æˆ‘ä»¬å¯ä»¥ç›´æ¥è€ƒè™‘"arr[i+1, j-1]"ä½†ä¹Ÿä¸ä¸€å®š, å› ä¸ºæœ‰å¯èƒ½$i$æ˜¯å’Œå‰é¢çš„æŸäº›å­—ç¬¦ä¸²å·²ç»ç»„æˆäº†`palindrome`, æ‰€ä»¥æ‰æœ‰å€’æ•°ç¬¬äºŒæ­¥. 
```python
def minimumMoves(self, A: List[int]) -> int:
    N = len(A); dp = [[0] * N for _ in range(N)]

    def helper(i=0, j=N-1):
        if j < i:  return 0
        if j == i: return 1
        if dp[i][j] != 0: return dp[i][j]
        res, tmp = float('inf'), 0
        for k in range(i+1, j):
            if A[i] == A[k]:
                if k == i + 1:  #they are right next to each other
                    tmp = 1 + helper(k+1, j)
                else:
                    tmp = helper(i+1, k-1) + helper(k+1, j)
                res = min(res, tmp)
        dp[i][j] = res = min(res, 1 + helper(i+1, j))
        return res
    
    return helper()
```
:::

![](~@assets/lc-1246.png#center)